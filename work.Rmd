---
title: "Projeto final"
author: "Diego"
date: "3/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, cache=TRUE, warning = FALSE, results = "hide")
```

# Libraries

```{r echo=FALSE}
library(garchmodels)
library(timetk)
library(tidyverse)
library(tidymodels)
library(BatchGetSymbols)
library(forecast)
library(tseries)
library(feasts)
library(tidyr)
library(recipes)
library(workflows)
library(tidymodels)
```


# Stocks gathering
```{r}
stocks <- c("ibov3", "ENBR3", "")

# "VALE3.SA",
my_stocks <- c("ITUB3.SA", "ENBR3.SA",
               "FLRY3.SA", "B3SA3.SA", "BBDC3.SA",
               "EGIE3.SA", "TAEE11.SA", "WEGE3.SA", 
               "PSSA3.SA"
               )

asset_returns <- 
  BatchGetSymbols(my_stocks,
                first.date = "2000-01-01",
                bench.ticker = "^BVSP",
                type.return = "log",
                freq.data = "daily",
                do.complete.data = TRUE,
                do.fill.missing.prices = TRUE
                )$df.tickers %>% 
  select(ref.date, ticker, ret.closing.prices, price.close)

asset_returns %>% 
  group_by(ticker) %>% 
  count()
``` 

 
# Retornos e autocorrelação

```{r}

plot_returns <- function (stock) ts.plot(stock)


tickers <- asset_returns$ticker %>% 
  unique


for (t in tickers) {
  df <- asset_returns %>% 
    filter(ticker == t)
  
  if (t == "ENBR3.SA") {
    df <- df %>%
      filter(ref.date > (df$ref.date[1] + 2000))
  }
  
  if (t == "WEGE3.SA")  {
    df <- df %>% 
      filter(ref.date > (df$ref.date[1] + 2000))
  }
  
  
  if (t == "WEGE3.SA")  {
    df <- df %>% 
      filter(ref.date > (df$ref.date[1] + 1000))
  }
  
  
  par(mfrow=c(1, 2))
  
  ts.plot(df$price.close)
  ts.plot(df$ret.closing.prices, main=paste("Ticker", t)) 
  par(mfrow=c(1,1))
    
}

```

Os retornos aparentemente são estacionários. Iremos fazer o teste de ljung-box para confirmar o ruído branco nos resíduos e também realizar o teste de raíz unitária.


```{r, results = "show"}

box_test <- function (df, lag = 1, type = 'Ljung-Box') Box.test(df, lag = lag, type = type)

for (t in tickers) {
  df <- asset_returns %>% 
    filter(ticker == t)
  
  acf(df$ret.closing.prices, main = paste("ACF", t)) %>% 
    autoplot() %>% 
    theme(
      plot.title = element_text(vjust = -50)
    )
  
  print(t)
  print(box_test(df$ret.closing.prices))
  print(adf.test(df$ret.closing.prices))
}

```

# Busca por melhor modelo a partir do tune

```{r}

fit_ts_stock <- function (stock) {
  if (nrow(stock) > 0) {
    
    stock <- stock %>%
      timetk::future_frame(
        .length_out = 3,
        .date_var = ref.date,
        .bind_data = TRUE
      ) %>%
      mutate(ref.date = as.POSIXct(ref.date))

    stock_train <- stock %>%
        drop_na()

    stock_future <- stock %>%
      filter(is.na(ret.closing.prices))

    # stock_train %>%
    #   mutate(
    #     ret2 = ret.closing.prices ^ 2
    #   ) %>%
    #   ggplot(
    #     aes(ref.date, ret2)
    #   ) +
    #   geom_line()
    # 
    # stock_future %>%
    #   print


    stock_model <- garchmodels::garch_reg(
      mode = "regression",
      arch_order = tune::tune(),
      garch_order = tune::tune(),
      ma_order = tune::tune(),
      ar_order = tune::tune(),
      tune_by = "sigmaFor"
    ) %>%
      parsnip::set_engine("rugarch")

    stock_recipe <- recipes::recipe(
      ret.closing.prices ~ ref.date,
      data = stock_train
    )

    stock_wflw <- workflow() %>%
      add_recipe(stock_recipe) %>%
      add_model(stock_model)

    stock_resamples <-  time_series_cv(
        stock_train,
        date_var = ref.date,
        initial = "1 year",
        assess = "3 months",
        skip = "1 month",
        cumulative = TRUE,
        slice_limit = 5
    )

    stock_tune_results <- tune_grid(
      object = stock_wflw,
      resamples = stock_resamples,
      param_info = dials::parameters(stock_wflw),
      grid = 5,
      control = control_grid(
        verbose = TRUE,
        allow_par = TRUE,
        parallel_over = "everything"
      )
    )


    stock_tune_results %>%
      tune::show_best(metric = "rmse")
  }
} 


asset_returns %>% 
  filter(ticker == tickers[6]) %>% 
  select(ref.date, ret.closing.prices) %>% 
  drop_na() %>% 
  fit_ts_stock

# for (t in tickers) {
#   asset_returns %>% 
#     filter(ticker == t) %>% 
#     select(ref.date, ret.closing.prices) %>% 
#     drop_na() %>% 
#     fit_ts_stock
# }

```



```{r}
dlm_routine <- function (df, ticker_string, index_string) {
  my_dlm = function(parm, x.mat) {
    parm = exp(parm)
    return (
      dlmModReg(
        X = x.mat, 
        dV = parm[1], 
        dW = c(parm[2], parm[3])
      )
    )
  }
  

  ticker_ret <- df %>%
    dplyr::select('ref.date','ticker','ret.closing.prices') %>%
    dplyr::filter(ticker == ticker_string) %>%
    drop_na('ret.closing.prices')
  
  index_ret <- df %>%
    dplyr::select('ref.date', 'ticker','ret.closing.prices') %>%
    dplyr::filter(ticker == index_string) %>%
    drop_na('ret.closing.prices')
  

  rang = range(
    index_ret$ret.closing.prices,
    ticker_ret$ret.closing.prices
  )

  plot(
    index_ret$ret.closing.prices,
    ticker_ret$ret.closing.prices,
    xlab = paste0("Market return", index_string),
    ylab=ticker_string,
    xlim=rang,
    ylim=rang
  )
  
  capm_ticker <- lm(ticker_ret$ret.closing.prices ~ index_ret$ret.closing.prices)
  
  abline(
     capm_ticker$coef,
     col = 2,
     lwd = 3
   )
  
 title(
   paste(
     ticker_string,
     "=",
     round(capm_ticker$coef[1],4)," + ",
     round(capm_ticker$coef[2],4),
     "*SP500",
     sep=""
   )
 )
  
    
  fit <- dlmMLE(
    y = ticker_ret$ret.closing.prices,
    parm = c(1, 1, 1),
    x.mat = index_ret$ret.closing.prices,
    build = my_dlm,
    hessian = T
  )

  se = sqrt(exp(fit$par))

  mod_std  = my_dlm(fit$par, index_ret$ret.closing.prices)
  mod_filt = dlmFilter(ticker_ret$ret.closing.prices, mod_std)
  mod_smot = dlmSmooth(mod_filt)

  date = ticker_ret$ref.date

  plot(
    date,
    mod_filt$m[,1][-1],
    xlab = "day",
    ylab = expression(alpha[t]),
    type = "l",
    main = ""
  )

  lines(
    date,
    mod_smot$s[,1][-1],
    col = 2
  )
  abline(
    h = capm_ticker$coef[1],
    col=3
   )
  abline(h = 1, lty = 2)
  
  
  plot(date,
       mod_filt$m[,2][-1],
       xlab = "day",
       ylab = expression(beta[t]),
       type = "l",
       main = ""
 )
  lines(date,
        mod_smot$s[,2][-1],
        col=2
  )
  
  abline(
    h=capm_ticker$coef[2],
    col=3
  )
  abline(h = 1, lty = 2)
  
  
  date
}
```

