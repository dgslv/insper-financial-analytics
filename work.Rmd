---
title: "Projeto final"
author: "Diego"
date: "3/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE, results = "hide", cache = TRUE)
```

# Libraries

```{r echo=FALSE}
library(timetk)
library(tidyverse)
library(tidymodels)
library(BatchGetSymbols)
library(forecast)
library(tseries)
library(feasts)
library(tidyquant)
library(tidyr)
library(recipes)
library(workflows)
library(tidymodels)
library(FinTS)
library(rugarch)
library(dlm)
library(garchmodels)
```


# Stocks gathering
```{r}
my_stocks <- c("ITUB3.SA", "ENBR3.SA",
               "FLRY3.SA", "B3SA3.SA", "BBDC3.SA",
               "EGIE3.SA", "TAEE11.SA", "WEGE3.SA", 
               "PSSA3.SA", "^BVSP")

all_asset_returns <- 
  BatchGetSymbols(my_stocks,
                first.date = "2000-01-01",
                bench.ticker = "^BVSP",
                type.return = "log",
                freq.data = "daily"
                )$df.tickers %>% 
  select(ref.date, ticker, ret.closing.prices, price.close) %>% 
  drop_na()

``` 

```{r}
tickers_filter_table = tibble(
      stock = all_asset_returns$ticker %>% 
        unique,
      add_date = c(0, 2300, 2000, 0, 3000, 4000, 0)
    )


do_filter_ref_date <- function(stock, filter_table) {
  stock %>% 
      filter(ref.date > (
        stock$ref.date[1] + 
          filter_table$add_date[filter_table$stock == stock$ticker[1]]
        )
      )
}

asset_returns <- read_csv("\n", col_names = names(all_asset_returns)) %>% 
  mutate(
    ref.date = as.Date(ref.date),
    ret.closing.prices = as.numeric(),
    price.close = as.numeric(),
  )


for (t in unique(all_asset_returns$ticker)) {
  asset_returns <- asset_returns %>% 
    add_row(all_asset_returns %>% 
              filter(ticker == t) %>% 
              drop_na('ret.closing.prices') %>% 
              do_filter_ref_date(tickers_filter_table))
}
```

 
# Funções - retornos e acf

```{r}

plot_returns <- function(stock) {
  if (nrow(stock) > 0) {
    df_plot <- stock
    
    par(mfrow=c(1, 3))
    
    ts.plot(df_plot$price.close, main = paste("Ticker", stock$ticker[1], " closing prices"))
    ts.plot(
      df_plot$ret.closing.prices, 
      main = paste("Ticker", stock$ticker[1], "ret")
            )
    ts.plot(
      df_plot$ret.closing.prices^2,
      main = paste("Ticker", stock$ticker[1], "ret^2")
    )
  }
}

plot_asset_returns <- function (asset_returns) {
  tickers <- asset_returns$ticker %>%
    unique

  for (t in tickers) {
      asset_returns %>% 
        filter(ticker == t) %>% 
        plot_returns()
    }
}

box_test <- function (df, lag = 1, type = 'Ljung-Box') Box.test(df, lag = lag, type = type)

descriptive_asset_evaluation <- function (asset_returns) {
  tickers <- asset_returns$ticker %>% 
    unique
  
  for (t in tickers) {
    df_box <- asset_returns %>% 
      filter(ticker == t)
    
    acf(df_box$ret.closing.prices, main = paste("ACF", t)) %>% 
      autoplot() %>% 
      theme(
        plot.title = element_text(vjust = -50)
      )
    
    print(box_test(df_box$ret.closing.prices))
    print(adf.test(df_box$ret.closing.prices))
    print(ArchTest(df_box$ret.closing.prices))
  }
}


visualize_residual_distribution <- function(asset_returns) {
  tickers <- asset_returns$ticker %>% 
    unique
  
  par(mfrow = c(1,2))
  for (t in tickers) {
    ret <- (asset_returns %>% 
        filter(ticker == t) %>% 
        drop_na('ret.closing.prices'))$ret.closing.prices
    
    h <- hist(ret, 
              breaks=20, 
              col="red", 
              xlab="", 
              main= paste("Histogram", t)
          ) 
    xfit <- seq(min(ret),
                max(ret),
                length = 40) 
    yfit <- dnorm(xfit,
                  mean = mean(ret),
                  sd = sd(ret)) 
    yfit <- yfit * diff(h$mids[1:2]) * length(ret) 
    lines(xfit, yfit, col="blue", lwd=2)
    
    qqnorm(ret, pch = 1, frame = FALSE)
    qqline(ret, col = "steelblue", lwd = 2)
    
    print(paste("Realizando teste de normalidade para o ticker", t))
    print(shapiro.test(as.vector(ret[c(1:4999)])))
  }
  
}

calculate_assets_beta <- function (asset_returns) {
  asset_returns %>%
    group_by(ticker) %>%
    do(model = lm(ret.closing.prices ~ market_ret$ret.closing.prices,
              data = .))
}
```

# Séries \nPreços de fechamento, retornos e retornos quadrados

<div style="width: 100% important!"> 
```{r}
plot_asset_returns(asset_returns)
```

</div> 

Os retornos aparentemente são estacionários. Iremos fazer o teste de ljung-box para confirmar o ruído branco nos resíduos e também realizar o teste de raíz unitária.

## ACF
```{r, results = "show"}
descriptive_asset_evaluation(asset_returns)
```

## Residual distribution

```{r}
visualize_residual_distribution(asset_returns)
```

# Busca por melhor modelo a partir do tune

```{r}
calculate_portfolio_covariability <- function(tib_returns) {
    cov(tib_returns$returns, tib_returns$ret.closing.prices) / var(tib_returns$ret.closing.prices)
}

```

## garchmodels que nao funciona 
```{r}
fit_ts_stock <- function (stock) {
    if (nrow(stock) > 0) {
      stock <- stock %>%
        timetk::future_frame(
          .length_out = 3,
          .date_var = ref.date,
          .bind_data = TRUE
        ) %>%
        mutate(ref.date = as.POSIXct(ref.date))
  
      stock_train <- stock %>%
          drop_na()
  
      stock_future <- stock %>%
        filter(is.na(ret.closing.prices))
  
      stock_model <- garchmodels::garch_reg(
        mode = "regression",
        arch_order = tune::tune(),
        garch_order = tune::tune(),
        ma_order = tune::tune(),
        ar_order = tune::tune(),
        tune_by = "sigmaFor"
      ) %>%
        parsnip::set_engine("rugarch")

      stock_recipe <- recipes::recipe(
        ret.closing.prices ~ ref.date,
        data = stock_train
      )

      stock_wflw <- workflow() %>%
        add_recipe(stock_recipe) %>%
        add_model(stock_model)

      stock_resamples <-  time_series_cv(
          stock_train,
          date_var = ref.date,
          initial = "1 year",
          assess = "3 months",
          skip = "1 month",
          cumulative = TRUE,
          slice_limit = 5
      )

      stock_tune_results <- tune_grid(
        object = stock_wflw,
        resamples = stock_resamples,
        param_info = dials::parameters(stock_wflw),
        grid = 5,
        control = control_grid(
          verbose = TRUE,
          allow_par = TRUE,
          parallel_over = "everything"
        )
      )


      
      ticker <- unique(stock$ticker)[1]
      
      stock_tune_results$ticker <- ticker
      
      stock_tune_results
    }
} 



results <- asset_returns %>% 
  group_split(ticker) %>% 
  map(fit_ts_stock)
```

Obtendo melhores modelos 

```{r}
bestOrders <- data.frame(ticker = NA, 
                   arch_order = NA, 
                   garch_order = NA, 
                   ar_order = NA, 
                   ma_order = NA, 
                   .metric = NA, 
                   mean = NA
                   )

for (r in results) {
  bestOrders <- bestOrders %>% 
    add_row(
    r %>% 
      tune::show_best(metric = "rmse") %>% 
      slice_head(n = 1) %>% 
        select(ticker, arch_order, garch_order, ar_order, ma_order, .metric, mean)    
    )
}


bestOrders <- bestOrders %>% 
  drop_na()
```

```{r}
bestOrders
```

## Ajustando garch para os modelos após encontrar os melhores resultados

```{r}
evaluate_garch <- function(ticker, data, bestTickerOrder) {
  print(paste("Ticker", ticker, "usando os modelos"))
  print(bestTickerOrder)
  
  garch_fit <- garchmodels::garch_reg(
      mode = "regression",
      arch_order = bestTickerOrder$arch_order,
      garch_order = bestTickerOrder$garch_order,
      ma_order = bestTickerOrder$ma_order,
      ar_order = bestTickerOrder$ar_order
    ) %>%
      parsnip::set_engine(
        "rugarch", 
        mean.model = list(include.mean = FALSE)
      ) %>%
      parsnip::fit(
        ret.closing.prices ~ ref.date, 
        data = data
      )
  
  garch_fit
}

garch_forecast <- function(garch_fit) {
  garch_forecast <- ugarchforecast(garch_fit, n.ahead = 1)
  garch_forecast %>% 
    plot
}

make_asset_garchs <- function(asset_returns, bestOrders) {
  if (nrow(bestOrders) > 0 & nrow(asset_returns) > 0) {
    tickers <- asset_returns$ticker %>% 
      unique
    
    models <- tibble(ticker = NA, model = NA)
    
    for (t in tickers) {
      print(paste("Rodando garch para a ação ", t))
      ret <- (asset_returns %>% 
        filter(ticker == t) %>% 
          drop_na('ret.closing.prices') %>% 
          mutate(
            returns = ret.closing.prices
          ))
      
      ticker_best <- bestOrders %>% 
        filter(ticker == t)
      
      fit_result <- evaluate_garch(t, ret, ticker_best)
      
      models <- models %>% 
        add_row(ticker = t, model = c(fit_result))
    }
    
    models
  } else {
    print("Assets e ordens dos garchs são necessários")
  }
}


result <- make_asset_garchs(asset_returns, bestOrders)
```

# Analisando CAPM

## Qual o risco de cada ação em relação ao mercado?

```{r}
evaluate_assets <- function(tickers, 
                            bench_ticker = "^BVSP", 
                            market = "^BVSP",
                            first.date = "2000-01-01", 
                            last.date = Sys.Date(),
                            assets_weights = NULL
                            ) {
  asset_returns <- BatchGetSymbols(tickers,
                first.date = first.date,
                last.date = last.date,
                bench.ticker = bench_ticker,
                type.return = "log",
                freq.data = "daily"
                )$df.tickers %>% 
  select(ref.date, ticker, ret.closing.prices) %>% 
    drop_na()
  
  tickers <- asset_returns$ticker %>% 
    unique
    
  for (t in tickers) {
    asset_returns %>%
      filter(ticker == t) %>%
      select(ref.date, ret.closing.prices) %>%
      drop_na()
  }
  
  
  portfolio_ret <- asset_returns %>%
  tq_portfolio(assets_col  = ticker,
               returns_col = ret.closing.prices,
               weights     = assets_weights,
               col_rename  = "returns")
  
  market_ret <-
    BatchGetSymbols(market,
               first.date = first.date,
               last.date = last.date,
               freq.data = "daily",
               type.return = "log")$df.tickers %>%
    select(ref.date, ret.closing.prices) %>% 
    as_tibble()
  
  ts.plot(portfolio_ret$returns)
  ts.plot(market_ret$ret.closing.prices)
  
  portfolio_market_ts <- portfolio_ret %>% 
     inner_join(market_ret, by = 'ref.date') 

  calculate_portfolio_covariability(portfolio_market_ts)
  
  betas <- asset_returns %>%
    group_by(ticker) %>%
    inner_join(market_ret, by = 'ref.date') %>% 
    do(model = lm(ret.closing.prices.x ~ ret.closing.prices.y,
              data = .))

  betas
}


assets_lm <- evaluate_assets(my_stocks)

assets_lm$betas <- map(assets_lm$model, coef) %>% 
  map_dbl(2)

assets_lm

## para calcular o beta do portfolio precisamos dos weights de cada uma das ações, e então multiplicar cada beta com o seu peso respectivo - leia-se beta_porfolio_byhand do arquivo capm_model.rmd

```


# Dynamic model - CAPM

```{r}
dlm_routine <- function (df, ticker_string, index_string) {
  my_dlm = function(parm, x.mat) {
    parm = exp(parm)
    return (
      dlmModReg(
        X = x.mat, 
        dV = parm[1], 
        dW = c(parm[2], parm[3])
      )
    )
  }
  

  ticker_ret <- df %>%
    dplyr::select('ref.date','ticker','ret.closing.prices') %>%
    dplyr::filter(ticker == ticker_string) %>%
    drop_na('ret.closing.prices')
  
  index_ret <- df %>%
    dplyr::select('ref.date', 'ticker','ret.closing.prices') %>%
    dplyr::filter(ticker == index_string) %>%
    drop_na('ret.closing.prices')
  

  rang = range(
    index_ret$ret.closing.prices,
    ticker_ret$ret.closing.prices
  )
  
  tib_returns <- ticker_ret %>% 
    inner_join(index_ret, by = 'ref.date')
  
  
  print(tib_returns)

  plot(
    tib_returns$ret.closing.prices.y,
    tib_returns$ret.closing.prices.x,
    xlab = paste0("Market return", index_string),
    ylab=ticker_string,
    xlim=rang,
    ylim=rang
  )
  
  capm_ticker <- lm(tib_returns$ret.closing.prices.x ~ tib_returns$ret.closing.prices.y)
  
  abline(
     capm_ticker$coef,
     col = 2,
     lwd = 3
   )
  
 title(
   paste(
     ticker_string,
     "=",
     round(capm_ticker$coef[1],4)," + ",
     round(capm_ticker$coef[2],4),
     "*SP500",
     sep=""
   )
 )
  
    
  fit <- dlmMLE(
    y = tib_returns$ret.closing.prices.x,
    parm = c(1, 1, 1),
    x.mat = tib_returns$ret.closing.prices.y,
    build = my_dlm,
    hessian = T
  )

  se = sqrt(exp(fit$par))

  mod_std  = my_dlm(fit$par, tib_returns$ret.closing.prices.y)
  mod_filt = dlmFilter(tib_returns$ret.closing.prices.x, mod_std)
  mod_smot = dlmSmooth(mod_filt)
  
  # colocamos o codigo original (com date -1) e não funcionou
  # colocamos sem e parece estar tudo ok 
  date = tib_returns$ref.date
  
  print(paste("isso", length(date)))
  print(paste("esse", length(mod_filt$m[,1][-1])))
  plot(
    date,
    mod_filt$m[,1][-1],
    xlab = "day",
    ylab = expression(alpha[t]),
    type = "l",
    main = ""
  )

  lines(
    date,
    mod_smot$s[,1][-1],
    col = 2
  )
  abline(
    h = capm_ticker$coef[1],
    col=3
   )
  abline(h = 1, lty = 2)
  
  
  plot(date,
       mod_filt$m[,2][-1],
       xlab = "day",
       ylab = expression(beta[t]),
       type = "l",
       main = ""
 )
  lines(date,
        mod_smot$s[,2][-1],
        col=2
  )
  
  abline(
    h=capm_ticker$coef[2],
    col=3
  )
  abline(h = 1, lty = 2)
}

dlm_routine(asset_returns, ticker_string = "ITUB3.SA", index_string = "^BVSP")
```



```{r}
for (t in unique(asset_returns$ticker)) {
  print(paste("Info criteria do ticker", t))
  print(infocriteria((result %>% 
    filter(ticker == t))$fit[[1]]))
}

```

