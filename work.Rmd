---
title: "Projeto final"
author: "Diego"
date: "3/12/2022"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, results = "hide")
```

# Libraries

```{r echo=FALSE}
library(timetk)
library(tidyverse)
library(tidymodels)
library(BatchGetSymbols)
library(forecast)
library(tseries)
library(feasts)
library(tidyquant)
library(tidyr)
library(recipes)
library(workflows)
library(tidymodels)
library(FinTS)
library(rugarch)
```


# Stocks gathering
```{r}
my_stocks <- c("ITUB3.SA", "ENBR3.SA",
               "FLRY3.SA", "B3SA3.SA", "BBDC3.SA",
               "EGIE3.SA", "TAEE11.SA", "WEGE3.SA", 
               "PSSA3.SA")

all_asset_returns <- 
  BatchGetSymbols(my_stocks,
                first.date = "2000-01-01",
                bench.ticker = "^BVSP",
                type.return = "log",
                freq.data = "daily"
                )$df.tickers %>% 
  select(ref.date, ticker, ret.closing.prices, price.close) %>% 
  drop_na()
``` 

```{r}
tickers_filter_table = tibble(
      stock = all_asset_returns$ticker %>% 
        unique,
      add_date = c(0, 2300, 2000, 0, 3000, 4000)
    )


do_filter_ref_date <- function(stock, filter_table) {
  stock %>% 
      filter(ref.date > (
        stock$ref.date[1] + 
          filter_table$add_date[filter_table$stock == stock$ticker[1]]
        )
      )
}

asset_returns <- read_csv("\n", col_names = names(all_asset_returns)) %>% 
  mutate(
    ref.date = as.Date(ref.date),
    ret.closing.prices = as.numeric(),
    price.close = as.numeric(),
  )


for (t in unique(all_asset_returns$ticker)) {
  asset_returns <- asset_returns %>% 
    add_row(all_asset_returns %>% 
              filter(ticker == t) %>% 
              drop_na('ret.closing.prices') %>% 
              do_filter_ref_date(tickers_filter_table))
}

```

 
# Funções - retornos e acf

```{r}

plot_returns <- function(stock) {
  if (nrow(stock) > 0) {
    df_plot <- stock
    
    par(mfrow=c(1, 3))
    
    ts.plot(df_plot$price.close, main = paste("Ticker", stock$ticker[1], " closing prices"))
    ts.plot(
      df_plot$ret.closing.prices, 
      main = paste("Ticker", stock$ticker[1], "ret")
            )
    ts.plot(
      df_plot$ret.closing.prices^2,
      main = paste("Ticker", stock$ticker[1], "ret^2")
    )
  }
}

plot_asset_returns <- function (asset_returns) {
  tickers <- asset_returns$ticker %>%
    unique

  for (t in tickers) {
      asset_returns %>% 
        filter(ticker == t) %>% 
        plot_returns()
    }
}

box_test <- function (df, lag = 1, type = 'Ljung-Box') Box.test(df, lag = lag, type = type)

descriptive_asset_evaluation <- function (asset_returns) {
  tickers <- asset_returns$ticker %>% 
    unique
  
  for (t in tickers) {
    df_box <- asset_returns %>% 
      filter(ticker == t)
    
    acf(df_box$ret.closing.prices, main = paste("ACF", t)) %>% 
      autoplot() %>% 
      theme(
        plot.title = element_text(vjust = -50)
      )
    
    print(box_test(df_box$ret.closing.prices))
    print(adf.test(df_box$ret.closing.prices))
    print(ArchTest(df_box$ret.closing.prices))
  }
}


visualize_residual_distribution <- function(asset_returns) {
  tickers <- asset_returns$ticker %>% 
    unique
  
  par(mfrow = c(1,2))
  for (t in tickers) {
    ret <- (asset_returns %>% 
        filter(ticker == t) %>% 
        drop_na('ret.closing.prices'))$ret.closing.prices
    
    h <- hist(ret, 
              breaks=20, 
              col="red", 
              xlab="", 
              main= paste("Histogram", t)
          ) 
    xfit <- seq(min(ret),
                max(ret),
                length = 40) 
    yfit <- dnorm(xfit,
                  mean = mean(ret),
                  sd = sd(ret)) 
    yfit <- yfit * diff(h$mids[1:2]) * length(ret) 
    lines(xfit, yfit, col="blue", lwd=2)
    
    qqnorm(ret, pch = 1, frame = FALSE)
    qqline(ret, col = "steelblue", lwd = 2)
    
    print(paste("Realizando teste de normalidade para o ticker", t))
    print(shapiro.test(as.vector(ret[c(1:4999)])))
  }
  
}

calculate_assets_beta <- function (asset_returns) {
  asset_returns %>%
    group_by(ticker) %>%
    do(model = lm(ret.closing.prices ~ market_ret$ret.closing.prices,
              data = .))
}
```

## Asset series, returns and squared ret
```{r}
plot_asset_returns(asset_returns)
```

Os retornos aparentemente são estacionários. Iremos fazer o teste de ljung-box para confirmar o ruído branco nos resíduos e também realizar o teste de raíz unitária.

## ACF
```{r, results = "show"}
descriptive_asset_evaluation(asset_returns)
```

## Residual distribution

```{r}
visualize_residual_distribution(asset_returns)
```

# Busca por melhor modelo a partir do tune

```{r}
calculate_portfolio_covariability <- function(portfolio, market) {
  cov(portfolio$returns, market$ret.closing.prices) / var(market$ret.closing.prices)
}

```

### garchmodels que nao funciona 
```{r}
fit_ts_stock <- function (stock) {
    if (nrow(stock) > 0) {
      
      stock <- stock %>%
        timetk::future_frame(
          .length_out = 3,
          .date_var = ref.date,
          .bind_data = TRUE
        ) %>%
        mutate(ref.date = as.POSIXct(ref.date))
  
      stock_train <- stock %>%
          drop_na()
  
      stock_future <- stock %>%
        filter(is.na(ret.closing.prices))
  
  
      stock_model <- garchmodels::garch_reg(
        mode = "regression",
        arch_order = tune::tune(),
        garch_order = tune::tune(),
        ma_order = tune::tune(),
        ar_order = tune::tune(),
        tune_by = "sigmaFor"
      ) %>%
        parsnip::set_engine("rugarch")
  
      stock_recipe <- recipes::recipe(
        ret.closing.prices ~ ref.date,
        data = stock_train
      )
  
      stock_wflw <- workflow() %>%
        add_recipe(stock_recipe) %>%
        add_model(stock_model)
  
      stock_resamples <-  time_series_cv(
          stock_train,
          date_var = ref.date,
          initial = "1 year",
          assess = "3 months",
          skip = "1 month",
          cumulative = TRUE,
          slice_limit = 5
      )
  
      stock_tune_results <- tune_grid(
        object = stock_wflw,
        resamples = stock_resamples,
        param_info = dials::parameters(stock_wflw),
        grid = 5,
        control = control_grid(
          verbose = TRUE,
          allow_par = TRUE,
          parallel_over = "everything"
        )
      )
  
  
      stock_tune_results %>%
        tune::show_best(metric = "rmse")
    }
} 

evaluate_assets <- function(tickers, 
                            bench_ticker = "^BVSP", 
                            market = "^BVSP",
                            first.date = "2000-01-01", 
                            last.date = Sys.Date(),
                            assets_weights = NULL
                            ) {
  asset_returns <- BatchGetSymbols(tickers,
                first.date = first.date,
                last.date = last.date,
                bench.ticker = bench_ticker,
                type.return = "log",
                freq.data = "daily"
                )$df.tickers %>% 
  select(ref.date, ticker, ret.closing.prices) %>% 
    drop_na()
  
  tickers <- asset_returns$ticker %>% 
    unique
    
  for (t in tickers) {
    asset_returns %>%
      filter(ticker == t) %>%
      select(ref.date, ret.closing.prices) %>%
      drop_na()
  }
  
  
  portfolio_ret <- asset_returns %>%
  tq_portfolio(assets_col  = ticker,
               returns_col = ret.closing.prices,
               weights     = assets_weights,
               col_rename  = "returns")
  market_ret <-
    BatchGetSymbols(market,
               first.date = first.date,
               last.date = last.date,
               freq.data = "daily",
               type.return = "log")$df.tickers %>%
    select(ref.date, ret.closing.prices) %>%
    drop_na()
  
  ts.plot(portfolio_ret$returns)
  ts.plot(market_ret$ret.closing.prices)
  
  calculate_portfolio_covariability(portfolio_ret, market_ret)
  
  
  betas <- asset_returns %>%
    group_by(ticker) %>%
    do(model = lm(ret.closing.prices ~ market_ret$ret.closing.prices,
              data = .))
  
  betas$ticker
}


# evaluate_assets(my_stocks)

```


# Dynamic model

```{r}
dlm_routine <- function (df, ticker_string, index_string) {
  my_dlm = function(parm, x.mat) {
    parm = exp(parm)
    return (
      dlmModReg(
        X = x.mat, 
        dV = parm[1], 
        dW = c(parm[2], parm[3])
      )
    )
  }
  

  ticker_ret <- df %>%
    dplyr::select('ref.date','ticker','ret.closing.prices') %>%
    dplyr::filter(ticker == ticker_string) %>%
    drop_na('ret.closing.prices')
  
  index_ret <- df %>%
    dplyr::select('ref.date', 'ticker','ret.closing.prices') %>%
    dplyr::filter(ticker == index_string) %>%
    drop_na('ret.closing.prices')
  

  rang = range(
    index_ret$ret.closing.prices,
    ticker_ret$ret.closing.prices
  )

  plot(
    index_ret$ret.closing.prices,
    ticker_ret$ret.closing.prices,
    xlab = paste0("Market return", index_string),
    ylab=ticker_string,
    xlim=rang,
    ylim=rang
  )
  
  capm_ticker <- lm(ticker_ret$ret.closing.prices ~ index_ret$ret.closing.prices)
  
  abline(
     capm_ticker$coef,
     col = 2,
     lwd = 3
   )
  
 title(
   paste(
     ticker_string,
     "=",
     round(capm_ticker$coef[1],4)," + ",
     round(capm_ticker$coef[2],4),
     "*SP500",
     sep=""
   )
 )
  
    
  fit <- dlmMLE(
    y = ticker_ret$ret.closing.prices,
    parm = c(1, 1, 1),
    x.mat = index_ret$ret.closing.prices,
    build = my_dlm,
    hessian = T
  )

  se = sqrt(exp(fit$par))

  mod_std  = my_dlm(fit$par, index_ret$ret.closing.prices)
  mod_filt = dlmFilter(ticker_ret$ret.closing.prices, mod_std)
  mod_smot = dlmSmooth(mod_filt)

  date = ticker_ret$ref.date

  plot(
    date,
    mod_filt$m[,1][-1],
    xlab = "day",
    ylab = expression(alpha[t]),
    type = "l",
    main = ""
  )

  lines(
    date,
    mod_smot$s[,1][-1],
    col = 2
  )
  abline(
    h = capm_ticker$coef[1],
    col=3
   )
  abline(h = 1, lty = 2)
  
  
  plot(date,
       mod_filt$m[,2][-1],
       xlab = "day",
       ylab = expression(beta[t]),
       type = "l",
       main = ""
 )
  lines(date,
        mod_smot$s[,2][-1],
        col=2
  )
  
  abline(
    h=capm_ticker$coef[2],
    col=3
  )
  abline(h = 1, lty = 2)
  
  
  date
}
```

# Evaluating garch
```{r}
evaluate_garch <- function(ticker, data, mean.model, variance.model) {
  garch_spec <- ugarchspec(
    mean.model = mean.model,
    variance.model = variance.model,
    distribution.model = "std"
  ) 
  
  garch_fit <- ugarchfit(spec = garch_spec, data = data$returns[-1])
  
  tibble(ticker = ticker, fit = c(garch_fit), AIC = c(infocriteria(garch_fit)))
}

garch_forecast <- function(garch_fit) {
  garch_forecast <- ugarchforecast(garch_fit, n.ahead = 1)
  garch_forecast %>% 
    plot
}

make_asset_garchs <- function(asset_returns, garchOrders) {
  if (nrow(garchOrders) > 0 & nrow(asset_returns) > 0) {
    tickers <- asset_returns$ticker %>% 
      unique
    
    models <- tibble(ticker = NA, fit = NA, AIC = NA)
    
    for (t in tickers) {
      print(paste("Rodando garch para a ação ", t))
      ret <- (asset_returns %>% 
        filter(ticker == t) %>% 
          drop_na('ret.closing.prices') %>% 
          mutate(
            returns = ret.closing.prices
          ))
      
      mean.model <- (garchOrders %>% 
        filter(ticker == t))$mean.model
      
      variance.model <- (garchOrders %>% 
        filter(ticker == t))$variance.model
      
      fit_result <- evaluate_garch(t, ret, mean.model, variance.model)
      
      models <- models %>% 
        add_row(fit_result)
    }
    
    models
  } else {
    print("Assets e ordens dos garchs são necessários")
  }
}


garchOrders <- tibble(
  ticker = asset_returns$ticker %>% 
    unique(),
  mean.model = list(
    c(0, 0),
    c(0, 0),
    c(0, 0),
    c(0, 0),
    c(0, 0),
    c(0, 0)
  ),
  variance.model = list(
    c(0, 0),
    c(0, 0),
    c(0, 0),
    c(0, 0),
    c(0, 0),
    c(0, 0)
  )
)


# models <- make_asset_garchs(asset_returns, garchOrders, tickers_filter_table)
asset_returns %>% 
  filter(str_detect(ticker, 'ITUB')) %>% 
  make_asset_garchs(garchOrders)
```


```{r}

(models %>% 
  drop_na %>% 
  arrange(desc(AIC)))$fit
```

